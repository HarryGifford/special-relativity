{"version":3,"sources":["webpack://create-wasm-app/./src/canvas-utils.ts","webpack://create-wasm-app/./src/load-text.ts","webpack://create-wasm-app/./src/ui.ts","webpack://create-wasm-app/./src/camera.ts","webpack://create-wasm-app/./src/index.ts"],"names":["loadText","async","url","resp","fetch","ok","Error","statusText","text","saveState","sessionStorage","uiState","JSON","stringify","defaultUiState","cameraBeta","useFixedVelocity","useNoTimeDelay","galilean","simultaneityFrame","relativisticBeaming","dopplerEffect","getState","parse","initUi","el","slider","document","createElement","type","min","max","step","inputMode","value","toString","title","createSpeedSlider","addEventListener","e","target","HTMLInputElement","currValue","parseFloat","Number","isNaN","toggle","checked","createFixedSpeedToggle","galileanToggle","createGalileanToggle","relativisticBeamingToggle","createRelativisticBeamingToggle","dopplerEffectToggle","createDopplerEffectToggle","sliderLabel","appendChild","append","toggleLabel","galileanLabel","relativisticBeamingLabel","dopplerEffectLabel","simultaneityPicker","container","noTimeDelayLabel","noTimeDelayToggle","createNoTimeDelayToggle","button1","name","disabled","button1Label","button2","button2Label","onClick","parseInt","onclick","createSimultaneityPicker","uiEl","className","helptext","innerText","RelativisticUniversalCamera","position","scene","super","this","velocity","properVelocity","properAcceleration","dt","onAfterCheckInputsObservable","add","_camera","_eventState","cameraDirection","length","scaleInPlace","Math","exp","inertia","copyFrom","newProperVelocity","scale","maxProperSpeed2","lengthSquared","properSpeed2","invGamma","sqrt","scaleToRef","addInPlace","speed","undefined","maxSpeed2","gamma2","engine","getEngine","getDeltaTime","getFps","setAll","cameraRotation","_checkInputs","body","style","display","flexDirection","canvasContainer","flex","canvas","width","clientWidth","height","clientHeight","tabIndex","window","_e","createCanvas","speedIndicator","classList","initSpeedIndicator","vertexShaderSrc","fragShaderSrc","Promise","all","deterministicLockstep","lockstepMaxSteps","location","href","defaultCameraInfo","getNodeByID","defaultPosition","defaultRotation","rotationQuaternion","camera","keysDownward","push","keysDown","keysUpward","keysUp","keysLeft","keysRight","gamepadAngularSensibility","navigator","userAgent","match","inputs","addVirtualJoystick","minZ","maxZ","fov","initCamera","createCamera","update","setTarget","attachControl","clearColor","set","rgbMapTexture","skipFrustumClipping","shaders","meshes","filter","mesh","map","albedo","material","albedoTexture","shaderMaterial","vertexSource","fragmentSource","attributes","uniforms","defines","setTexture","runRenderLoop","setMaxSpeed","getDirection","forEach","shader","setVector3","setInt","toFixed","render","resize","focus","main","catch","console","error"],"mappings":"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","file":"770.bootstrap.js","sourcesContent":["export const createCanvas = (el: HTMLElement): HTMLCanvasElement => {\n  const canvas = document.createElement(\"canvas\");\n  canvas.style.position = \"absolute\";\n  canvas.width = el.clientWidth;\n  canvas.height = el.clientHeight;\n  canvas.style.position = \"fixed\";\n  canvas.tabIndex = 0;\n\n  window.addEventListener(\"resize\", _e => {\n    canvas.width = el.clientWidth;\n    canvas.height = el.clientHeight;\n  })\n\n  el.appendChild(canvas);\n  return canvas;\n};\n\n/**\n * Create and initialize the canvas and add to the DOM.\n *\n * @param el Element to add the canvas to.\n */\nexport const createGlContext = (\n  canvas: HTMLCanvasElement\n): WebGL2RenderingContext => {\n  const gl = canvas.getContext(\"webgl2\", {\n    antialias: true,\n  });\n\n  if (gl == null) {\n    throw new Error(\"Unable to create WebGL 2 context.\");\n  }\n\n  return gl;\n};\n","/** Load file as a string. */\nexport const loadText = async (url: string) => {\n  const resp = await fetch(url);\n  if (!resp.ok) {\n    throw new Error(resp.statusText);\n  }\n  return resp.text();\n};\n","export const enum SimultaneityFrame {\n  world = 0,\n  camera = 1\n}\n\n/** UI configuration used in this demo. */\nexport type UiState = {\n  /** Fraction of the speed of light the camera is traveling at. */\n  cameraBeta: number;\n  /** Use a fixed velocity as the speed of light. */\n  useFixedVelocity: boolean;\n  /** Don't take into account travel time of light to reach camera. */\n  useNoTimeDelay: boolean;\n  /**\n   * True to transform according to Euclidean space. False for special\n   * relativity.\n   */\n  galilean: boolean;\n  /**\n   * Used with `useNoTimeDelay` to define which frame to use to define\n   * when events are simultaneous.\n   */\n  simultaneityFrame: SimultaneityFrame;\n  /** Set to true to enable relativistic beaming. */\n  relativisticBeaming: boolean;\n  /** Set to true to doppler shift the wavelength of light. */\n  dopplerEffect: boolean;\n};\n\n/**\n * Save the state to session storage, which is preserved until the browser is\n * closed.\n */\nconst saveState = () => {\n  sessionStorage.uiState = JSON.stringify(uiState);\n};\n\nconst defaultUiState: UiState = {\n  cameraBeta: 0.95,\n  useFixedVelocity: false,\n  useNoTimeDelay: false,\n  galilean: false,\n  simultaneityFrame: SimultaneityFrame.world,\n  relativisticBeaming: false,\n  dopplerEffect: false\n};\n\nexport const getState = (): UiState => {\n  return sessionStorage.uiState != null\n    ? JSON.parse(sessionStorage.uiState)\n    : defaultUiState;\n};\n\nlet uiState: UiState = getState();\n\nconst createSpeedSlider = () => {\n  const slider = document.createElement(\"input\");\n  slider.type = \"number\";\n  slider.min = \"0\";\n  slider.max = \"1\";\n  slider.step = \"0.005\";\n  slider.inputMode = \"decimal\";\n  slider.value = uiState.cameraBeta?.toString();\n  slider.title =\n    \"Camera speed as a fraction of the speed of light.\"\n  return slider;\n};\n\nconst createFixedSpeedToggle = () => {\n  const toggle = document.createElement(\"input\");\n  toggle.type = \"checkbox\";\n  toggle.checked = uiState.useFixedVelocity;\n  return toggle;\n};\n\nconst createNoTimeDelayToggle = () => {\n  const toggle = document.createElement(\"input\");\n  toggle.type = \"checkbox\";\n  toggle.checked = uiState.useNoTimeDelay;\n  return toggle;\n};\n\nconst createGalileanToggle = () => {\n  const toggle = document.createElement(\"input\");\n  toggle.type = \"checkbox\";\n  toggle.checked = uiState.galilean;\n  return toggle;\n};\n\nconst createRelativisticBeamingToggle = () => {\n  const toggle = document.createElement(\"input\");\n  toggle.type = \"checkbox\";\n  toggle.checked = uiState.relativisticBeaming;\n  return toggle;\n};\n\nconst createDopplerEffectToggle = () => {\n  const toggle = document.createElement(\"input\");\n  toggle.type = \"checkbox\";\n  toggle.checked = uiState.dopplerEffect;\n  return toggle;\n};\n\nconst createSimultaneityPicker = () => {\n  const container = document.createElement(\"div\");\n\n  const noTimeDelayLabel = document.createElement(\"label\");\n  const noTimeDelayToggle = createNoTimeDelayToggle();\n  noTimeDelayLabel.appendChild(noTimeDelayToggle);\n  noTimeDelayLabel.append(\"Assume no light travel time in frame:\")\n  container.appendChild(noTimeDelayLabel);\n\n  const button1 = document.createElement(\"input\");\n  button1.name = \"simultaneity-frame\";\n  button1.type = \"radio\";\n  button1.disabled = !uiState.useNoTimeDelay;\n  button1.checked = uiState.simultaneityFrame === SimultaneityFrame.world;\n  button1.value = `${SimultaneityFrame.world}`;\n  const button1Label = document.createElement(\"label\");\n  button1Label.appendChild(button1);\n  button1Label.append(\"World\");\n\n  const button2 = document.createElement(\"input\");\n  button2.name = \"simultaneity-frame\";\n  button2.type = \"radio\";\n  button2.disabled = !uiState.useNoTimeDelay;\n  button2.checked = uiState.simultaneityFrame === SimultaneityFrame.camera;\n  button2.value = `${SimultaneityFrame.camera}`;\n  const button2Label = document.createElement(\"label\");\n  button2Label.appendChild(button2);\n  button2Label.append(\"Camera\");\n\n  noTimeDelayToggle.addEventListener(\"change\", e => {\n    const target = e.target;\n    if (target == null || !(target instanceof HTMLInputElement)) {\n      return;\n    }\n    const useNoTimeDelay = !!target.checked;\n    uiState.useNoTimeDelay = useNoTimeDelay;\n    saveState();\n\n    button1.disabled = !useNoTimeDelay;\n    button2.disabled = !useNoTimeDelay;\n  });\n\n  const onClick = (e: MouseEvent) => {\n    const target = e.target;\n    if (target == null || !(target instanceof HTMLInputElement)) {\n      return;\n    }\n    const value = parseInt(target.value, 10) as SimultaneityFrame;\n    uiState.simultaneityFrame = value;\n    saveState();\n  }\n  button1.onclick = onClick;\n  button2.onclick = onClick;\n\n  container.appendChild(button1Label);\n  container.appendChild(button2Label);\n\n  return container;\n}\n\nexport const initSpeedIndicator = (el: HTMLElement) => {\n  const speedIndicator = document.createElement(\"div\");\n  speedIndicator.classList.add(\"speed-indicator\");\n  el.appendChild(speedIndicator);\n  return speedIndicator;\n}\n\n/** Element to add the UI to. */\nexport const initUi = (el: HTMLElement) => {\n  uiState = getState();\n\n  const slider = createSpeedSlider();\n  slider.addEventListener(\"change\", (e) => {\n    const target = e.target;\n    if (target == null || !(target instanceof HTMLInputElement)) {\n      return;\n    }\n    const currValue = parseFloat(target.value);\n    if (!Number.isNaN(currValue)) {\n      uiState.cameraBeta = currValue;\n      saveState();\n    }\n  });\n\n  const toggle = createFixedSpeedToggle();\n  toggle.addEventListener(\"change\", (e) => {\n    const target = e.target;\n    if (target == null || !(target instanceof HTMLInputElement)) {\n      return;\n    }\n    const useFixedVelocity = target.checked;\n    uiState.useFixedVelocity = useFixedVelocity;\n    saveState();\n  });\n\n  const galileanToggle = createGalileanToggle();\n  galileanToggle.addEventListener(\"change\", (e) => {\n    const target = e.target;\n    if (target == null || !(target instanceof HTMLInputElement)) {\n      return;\n    }\n    uiState.galilean = !!target.checked;\n    saveState();\n  })\n\n  const relativisticBeamingToggle = createRelativisticBeamingToggle();\n  relativisticBeamingToggle.addEventListener(\"change\", (e) => {\n    const target = e.target;\n    if (target == null || !(target instanceof HTMLInputElement)) {\n      return;\n    }\n    uiState.relativisticBeaming = !!target.checked;\n    saveState();\n  });\n\n  const dopplerEffectToggle = createDopplerEffectToggle();\n  dopplerEffectToggle.addEventListener(\"change\", (e) => {\n    const target = e.target;\n    if (target == null || !(target instanceof HTMLInputElement)) {\n      return;\n    }\n    uiState.dopplerEffect = !!target.checked;\n    saveState();\n  });\n\n  const sliderLabel = document.createElement(\"label\");\n  sliderLabel.appendChild(slider);\n  sliderLabel.append(\"Max camera speed (fraction of c)\");\n\n  const toggleLabel = document.createElement(\"label\");\n  toggleLabel.appendChild(toggle);\n  toggleLabel.append(\"Assume fixed camera speed\");\n\n  const galileanLabel = document.createElement(\"label\");\n  galileanLabel.appendChild(galileanToggle);\n  galileanLabel.append(\"Use Galilean relativity\");\n\n  const relativisticBeamingLabel = document.createElement(\"label\");\n  relativisticBeamingLabel.appendChild(relativisticBeamingToggle);\n  relativisticBeamingLabel.append(\"Relativistic beaming\");\n\n  const dopplerEffectLabel = document.createElement(\"label\");\n  dopplerEffectLabel.appendChild(dopplerEffectToggle);\n  dopplerEffectLabel.append(\"Doppler effect\");\n\n  const simultaneityPicker = createSimultaneityPicker();\n\n  const uiEl = document.createElement(\"div\");\n  uiEl.className = \"main-ui\";\n\n  const helptext = document.createElement(\"div\");\n  helptext.innerText = \"Use WASD and mouse to move or touch on smartphone.\"\n  uiEl.appendChild(helptext);\n  uiEl.appendChild(sliderLabel);\n  uiEl.appendChild(relativisticBeamingLabel);\n  uiEl.appendChild(dopplerEffectLabel);\n  uiEl.appendChild(simultaneityPicker);\n  uiEl.appendChild(toggleLabel);\n  uiEl.appendChild(galileanLabel);\n  el.appendChild(uiEl);\n};\n","import {\n  Scene,\n  Vector3,\n  Epsilon,\n  UniversalCamera,\n  TargetCamera,\n} from \"@babylonjs/core\";\n\nexport interface RelativisticCamera extends TargetCamera {\n  velocity: Vector3;\n  properVelocity: Vector3;\n  /** Set the max (coordinate) speed. */\n  setMaxSpeed(speed: number | undefined): void;\n}\n\n/**\n * Modifications to the default camera to get smooth acceleration and\n * deceleration. This is necessary to get a smooth velocity.\n *\n * This could probably be replaced with a standard physics integrator.\n */\nclass RelativisticUniversalCamera extends UniversalCamera {\n  velocity: Vector3;\n  properVelocity: Vector3;\n  properAcceleration: Vector3;\n  dt: number;\n\n  maxProperSpeed2: number | undefined;\n\n  public setMaxSpeed(speed: number | undefined) {\n    if (speed == null) {\n      this.maxProperSpeed2 = undefined;\n      return;\n    }\n    const maxSpeed2 = speed * speed;\n    const gamma2 = 1 / (1 - maxSpeed2);\n    this.maxProperSpeed2 = gamma2 * maxSpeed2;\n  }\n\n  constructor(name: string, position: Vector3, scene: Scene) {\n    super(name, position, scene);\n    this.velocity = Vector3.Zero();\n    this.properVelocity = Vector3.Zero();\n    this.properAcceleration = Vector3.Zero();\n    this.dt = 0;\n\n    this.onAfterCheckInputsObservable.add((_camera, _eventState) => {\n      let dt = this.dt;\n      if (this.cameraDirection.length() <= Epsilon) {\n        // Keys are not pressed, so we decelerate. This is hacky, but\n        // I couldn't think of a better way to accelerate to a maximum speed\n        // but also have an inertia at the same time. If I could figure that\n        // out it would hopefully allow a much less ad hoc camera\n        // implementation.\n        this.properVelocity.scaleInPlace(Math.exp(-dt) * this.inertia);\n      } else {\n        // Otherwise, apply constant acceleration.\n        this.properAcceleration.copyFrom(this.cameraDirection);\n\n        // Euler integration step.\n        // It's ok to add the velocities normally here, since the\n        // timestep is small.\n        const newProperVelocity = this.properVelocity.add(\n          this.properAcceleration.scale(dt)\n        );\n        // If a max speed is set, then we should respect it.\n        if (\n          this.maxProperSpeed2 == null ||\n          newProperVelocity.lengthSquared() < this.maxProperSpeed2\n        ) {\n          this.properVelocity.copyFrom(newProperVelocity);\n        }\n      }\n      // Compute the normal velocity from the proper velocity.\n      const properSpeed2 = this.properVelocity.lengthSquared();\n      const invGamma = 1 / Math.sqrt(1 + properSpeed2);\n      this.properVelocity.scaleToRef(invGamma, this.velocity);\n      this.position.addInPlace(this.velocity.scale(dt));\n    });\n  }\n\n  public _computeLocalCameraSpeed() {\n    return this.speed;\n  }\n\n  public _checkInputs() {\n    var engine = this.getEngine();\n    // This is taken from the Babylon JS code. Not sure why it's not just\n    // `getDeltaTime`.\n    this.dt = Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n    // Reset the camera direction.\n    this.cameraDirection.setAll(0);\n    // Smoothly stop rotation when rotation is stopped.\n    this.cameraRotation.scaleInPlace(Math.exp(-this.dt) * this.inertia);\n\n    super._checkInputs();\n  }\n\n  /** Don't allow the default position update. */\n  public _updatePosition() {}\n}\n\n/**\n * Not great check, but used to determine if we should use a virtual\n * joystick or wasd keyboard.\n */\nconst runningSmartphone = () => {\n  return (\n    navigator.userAgent.match(/Android/i) ||\n    navigator.userAgent.match(/iPhone/i)\n  );\n};\n\nconst keyForward = 87;\nconst keyBackward = 83;\nconst keyUp = 69;\nconst keyDown = 81;\nconst keyRight = 68;\nconst keyLeft = 65;\n\nconst initCamera = (camera: RelativisticUniversalCamera) => {\n  // Enable WASD keys for camera control.\n  camera.keysDownward.push(keyDown);\n  camera.keysDown.push(keyBackward);\n  camera.keysUpward.push(keyUp);\n  camera.keysUp.push(keyForward);\n  camera.keysLeft.push(keyLeft);\n  camera.keysRight.push(keyRight);\n  camera.gamepadAngularSensibility = 100;\n  if (runningSmartphone()) {\n    camera.inputs.addVirtualJoystick();\n  }\n\n  camera.speed = 0.5;\n  camera.inertia = 0.9;\n  camera.minZ = 0.1;\n  camera.maxZ = 10000;\n  camera.fov = 0.9;\n};\n\nexport const createCamera = (\n  name: string,\n  position: Vector3,\n  scene: Scene\n): RelativisticCamera => {\n  const camera = new RelativisticUniversalCamera(name, position, scene);\n  initCamera(camera);\n  return camera;\n};\n","import {\n  Effect,\n  Engine,\n  InstancedMesh,\n  PBRMaterial,\n  SceneLoader,\n  ShaderMaterial,\n  TransformNode,\n  Vector3,\n  Texture\n} from \"@babylonjs/core\";\nimport \"@babylonjs/loaders/glTF/2.0\";\nimport { createCanvas } from \"./canvas-utils\";\nimport { loadText } from \"./load-text\";\nimport { getState, initUi, initSpeedIndicator } from \"./ui\";\nimport { createCamera } from \"./camera\";\n\nconst main = async () => {\n  const el = document.body;\n  el.style.display = \"flex\";\n  el.style.flexDirection = \"column\";\n  initUi(el);\n  const canvasContainer = document.createElement(\"div\");\n  canvasContainer.style.flex = \"1 1 auto\";\n  document.body.appendChild(canvasContainer);\n  const canvas = createCanvas(canvasContainer);\n\n  const speedIndicator = initSpeedIndicator(el);\n\n  const [vertexShaderSrc, fragShaderSrc] = await Promise.all([\n    loadText(\"main.vert\"),\n    loadText(\"main.frag\"),\n  ]);\n\n  const engine = new Engine(canvas, true, {\n    deterministicLockstep: true,\n    lockstepMaxSteps: 4,\n  });\n\n  Effect.ShadersStore[\"customVertexShader\"] = vertexShaderSrc;\n\n  Effect.ShadersStore[\"customFragmentShader\"] = fragShaderSrc;\n\n  const scene = await SceneLoader.LoadAsync(\n    window.location.href,\n    \"SubdividedCube.gltf\",\n    engine\n  );\n\n  const defaultCameraInfo = scene.getNodeByID(\"Camera\") as TransformNode;\n  const defaultPosition = defaultCameraInfo?.position || new Vector3(0, 0, -1);\n  const defaultRotation = defaultCameraInfo?.rotationQuaternion;\n\n  const camera = createCamera(\"camera1\", defaultPosition, scene);\n\n  if (defaultRotation != null) {\n    camera.rotationQuaternion = defaultRotation;\n    camera.update();\n  } else {\n    camera.setTarget(Vector3.Zero());\n  }\n  // This attaches the camera to the canvas\n  camera.attachControl(true);\n\n  scene.clearColor.set(0.2, 0.3, 0.6, 1);\n  const rgbMapTexture = new Texture(\"./lambda_rgb_map.png\", scene, false, undefined, Texture.BILINEAR_SAMPLINGMODE);\n\n  // Need to skip this due to movement of vertices from relativistic\n  // corrections.\n  scene.skipFrustumClipping = true;\n\n  const shaders = scene.meshes\n    .filter((mesh) => !(mesh instanceof InstancedMesh))\n    .map((mesh) => {\n      const material = mesh.material as PBRMaterial;\n      const albedo = material?.albedoTexture;\n\n      const shaderMaterial = new ShaderMaterial(\n        \"shader\" + mesh.name,\n        scene,\n        {\n          vertexSource: vertexShaderSrc,\n          fragmentSource: fragShaderSrc,\n        },\n        {\n          attributes: [\"position\", \"normal\", \"uv\"],\n          uniforms: [\n            \"world\",\n            \"finalWorld\",\n            \"worldView\",\n            \"worldViewProjection\",\n            \"view\",\n            \"projection\",\n            \"viewProjection\",\n            \"velocity\",\n            \"textureSampler\",\n            \"simultaneityFrame\",\n            \"useGalilean\",\n            \"useNoTimeDelay\",\n            \"rgbMapSampler\",\n            \"dopplerEffect\",\n            \"relativisticBeaming\"\n          ],\n          defines: albedo != null ? [\"#define HAS_TEXTURE\"] : [],\n        }\n      );\n      shaderMaterial.setTexture(\"rgbMapSampler\", rgbMapTexture);\n      if (albedo != null) {\n        shaderMaterial.setTexture(\"textureSampler\", albedo);\n      }\n      mesh.material = shaderMaterial;\n      return shaderMaterial;\n    });\n\n  // Register a render loop to repeatedly render the scene\n  engine.runRenderLoop(function () {\n    const {\n      cameraBeta,\n      galilean,\n      simultaneityFrame,\n      useFixedVelocity,\n      useNoTimeDelay,\n      relativisticBeaming,\n      dopplerEffect\n    } = getState();\n\n    // Set the maximum allowed speed.\n    camera.setMaxSpeed(cameraBeta);\n\n    let velocity =\n      camera.velocity == null || useFixedVelocity\n        ? camera.getDirection(Vector3.Forward()).scale(cameraBeta)\n        : camera.velocity;\n    shaders.forEach((shader) => {\n      shader\n        .setVector3(\"velocity\", velocity)\n        .setInt(\"useNoTimeDelay\", useNoTimeDelay ? 1 : 0)\n        .setInt(\"simultaneityFrame\", simultaneityFrame)\n        .setInt(\"useGalilean\", galilean ? 1 : 0)\n        .setInt(\"relativisticBeaming\", relativisticBeaming ? 1 : 0)\n        .setInt(\"dopplerEffect\", dopplerEffect ? 1 : 0);\n    });\n    // Set the speed indicator in the UI.\n    const speed = velocity.length();\n    speedIndicator.innerText = `Speed: ${speed.toFixed(3)}c`;\n\n    scene.render();\n  });\n\n  // Watch for browser/canvas resize events\n  window.addEventListener(\"resize\", function () {\n    engine.resize();\n  });\n  canvas.focus();\n};\n\nmain().catch(console.error);\n"],"sourceRoot":""}